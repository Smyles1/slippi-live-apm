{"version":3,"file":"slpParser.esm.js","sources":["../../src/utils/slpParser.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { get, keyBy, set } from \"lodash\";\nimport semver from \"semver\";\n\nimport type {\n  FrameBookendType,\n  FrameEntryType,\n  FrameStartType,\n  FramesType,\n  GameEndType,\n  GameStartType,\n  GeckoListType,\n  ItemUpdateType,\n  PostFrameUpdateType,\n  PreFrameUpdateType,\n  RollbackFrames,\n} from \"../types\";\nimport { Command, Frames, GameMode } from \"../types\";\nimport { RollbackCounter } from \"./rollbackCounter\";\n\nexport const MAX_ROLLBACK_FRAMES = 7;\n\nexport enum SlpParserEvent {\n  SETTINGS = \"settings\",\n  END = \"end\",\n  FRAME = \"frame\", // Emitted for every frame\n  FINALIZED_FRAME = \"finalized-frame\", // Emitted for only finalized frames\n  ROLLBACK_FRAME = \"rollback-frame\", // Emitted if a frame is being replaced\n}\n\n// If strict mode is on, we will do strict validation checking\n// which could throw errors on invalid data.\n// Default to false though since probably only real time applications\n// would care about valid data.\nconst defaultSlpParserOptions = {\n  strict: false,\n};\n\nexport type SlpParserOptions = typeof defaultSlpParserOptions;\n\nexport class SlpParser extends EventEmitter {\n  private frames: FramesType = {};\n  private rollbackCounter: RollbackCounter = new RollbackCounter();\n  private settings: GameStartType | null = null;\n  private gameEnd: GameEndType | null = null;\n  private latestFrameIndex: number | null = null;\n  private settingsComplete = false;\n  private lastFinalizedFrame = Frames.FIRST - 1;\n  private options: SlpParserOptions;\n  private geckoList: GeckoListType | null = null;\n\n  public constructor(options?: Partial<SlpParserOptions>) {\n    super();\n    this.options = Object.assign({}, defaultSlpParserOptions, options);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public handleCommand(command: Command, payload: any): void {\n    switch (command) {\n      case Command.GAME_START:\n        this._handleGameStart(payload as GameStartType);\n        break;\n      case Command.FRAME_START:\n        this._handleFrameStart(payload as FrameStartType);\n        break;\n      case Command.POST_FRAME_UPDATE:\n        // We need to handle the post frame update first since that\n        // will finalize the settings object, before we fire the frame update\n        this._handlePostFrameUpdate(payload as PostFrameUpdateType);\n        this._handleFrameUpdate(command, payload as PostFrameUpdateType);\n        break;\n      case Command.PRE_FRAME_UPDATE:\n        this._handleFrameUpdate(command, payload as PreFrameUpdateType);\n        break;\n      case Command.ITEM_UPDATE:\n        this._handleItemUpdate(payload as ItemUpdateType);\n        break;\n      case Command.FRAME_BOOKEND:\n        this._handleFrameBookend(payload as FrameBookendType);\n        break;\n      case Command.GAME_END:\n        this._handleGameEnd(payload as GameEndType);\n        break;\n      case Command.GECKO_LIST:\n        this._handleGeckoList(payload as GeckoListType);\n        break;\n    }\n  }\n\n  /**\n   * Resets the parser state to their default values.\n   */\n  public reset(): void {\n    this.frames = {};\n    this.settings = null;\n    this.gameEnd = null;\n    this.latestFrameIndex = null;\n    this.settingsComplete = false;\n    this.lastFinalizedFrame = Frames.FIRST - 1;\n  }\n\n  public getLatestFrameNumber(): number {\n    return this.latestFrameIndex ?? Frames.FIRST - 1;\n  }\n\n  public getPlayableFrameCount(): number {\n    if (this.latestFrameIndex === null) {\n      return 0;\n    }\n    return this.latestFrameIndex < Frames.FIRST_PLAYABLE ? 0 : this.latestFrameIndex - Frames.FIRST_PLAYABLE;\n  }\n\n  public getLatestFrame(): FrameEntryType | null {\n    // return this.playerFrames[this.latestFrameIndex];\n\n    // TODO: Modify this to check if we actually have all the latest frame data and return that\n    // TODO: If we do. For now I'm just going to take a shortcut\n    const allFrames = this.getFrames();\n    const frameIndex = this.latestFrameIndex !== null ? this.latestFrameIndex : Frames.FIRST;\n    const indexToUse = this.gameEnd ? frameIndex : frameIndex - 1;\n    return get(allFrames, indexToUse) || null;\n  }\n\n  public getSettings(): GameStartType | null {\n    return this.settingsComplete ? this.settings : null;\n  }\n\n  public getGameEnd(): GameEndType | null {\n    return this.gameEnd;\n  }\n\n  public getFrames(): FramesType {\n    return this.frames;\n  }\n\n  public getRollbackFrames(): RollbackFrames {\n    return {\n      frames: this.rollbackCounter.getFrames(),\n      count: this.rollbackCounter.getCount(),\n      lengths: this.rollbackCounter.getLengths(),\n    };\n  }\n\n  public getFrame(num: number): FrameEntryType | null {\n    return this.frames[num] || null;\n  }\n\n  public getGeckoList(): GeckoListType | null {\n    return this.geckoList;\n  }\n\n  private _handleGeckoList(payload: GeckoListType): void {\n    this.geckoList = payload;\n  }\n\n  private _handleGameEnd(payload: GameEndType): void {\n    // Finalize remaining frames if necessary\n    if (this.latestFrameIndex !== null && this.latestFrameIndex !== this.lastFinalizedFrame) {\n      this._finalizeFrames(this.latestFrameIndex);\n    }\n\n    payload = payload as GameEndType;\n    this.gameEnd = payload;\n    this.emit(SlpParserEvent.END, this.gameEnd);\n  }\n\n  private _handleGameStart(payload: GameStartType): void {\n    this.settings = payload;\n    const players = payload.players;\n    this.settings.players = players.filter((player) => player.type !== 3);\n\n    // Check to see if the file was created after the sheik fix so we know\n    // we don't have to process the first frame of the game for the full settings\n    if (payload.slpVersion && semver.gte(payload.slpVersion, \"1.6.0\")) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameStart(payload: FrameStartType): void {\n    const currentFrameNumber = payload.frame!;\n\n    set(this.frames, [currentFrameNumber, \"start\"], payload);\n  }\n\n  private _handlePostFrameUpdate(payload: PostFrameUpdateType): void {\n    if (this.settingsComplete) {\n      return;\n    }\n\n    // Finish calculating settings\n    if (payload.frame! <= Frames.FIRST) {\n      const playerIndex = payload.playerIndex!;\n      const playersByIndex = keyBy(this.settings!.players, \"playerIndex\");\n\n      switch (payload.internalCharacterId) {\n        case 0x7:\n          playersByIndex[playerIndex]!.characterId = 0x13; // Sheik\n          break;\n        case 0x13:\n          playersByIndex[playerIndex]!.characterId = 0x12; // Zelda\n          break;\n      }\n    }\n    if (payload.frame! > Frames.FIRST) {\n      this._completeSettings();\n    }\n  }\n\n  private _handleFrameUpdate(command: Command, payload: PreFrameUpdateType | PostFrameUpdateType): void {\n    payload = payload as PostFrameUpdateType;\n    const location = command === Command.PRE_FRAME_UPDATE ? \"pre\" : \"post\";\n    const field = payload.isFollower ? \"followers\" : \"players\";\n    const currentFrameNumber = payload.frame!;\n    this.latestFrameIndex = currentFrameNumber;\n    if (location === \"pre\" && !payload.isFollower) {\n      const currentFrame = this.frames[currentFrameNumber];\n      const wasRolledback = this.rollbackCounter.checkIfRollbackFrame(currentFrame, payload.playerIndex!);\n      if (wasRolledback) {\n        // frame is about to be overwritten\n        this.emit(SlpParserEvent.ROLLBACK_FRAME, currentFrame);\n      }\n    }\n    set(this.frames, [currentFrameNumber, field, payload.playerIndex!, location], payload);\n    set(this.frames, [currentFrameNumber, \"frame\"], currentFrameNumber);\n\n    // If file is from before frame bookending, add frame to stats computer here. Does a little\n    // more processing than necessary, but it works\n    const settings = this.getSettings();\n    if (settings && (!settings.slpVersion || semver.lte(settings.slpVersion, \"2.2.0\"))) {\n      this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n      // Finalize the previous frame since no bookending exists\n      this._finalizeFrames(currentFrameNumber - 1);\n    } else {\n      set(this.frames, [currentFrameNumber, \"isTransferComplete\"], false);\n    }\n  }\n\n  private _handleItemUpdate(payload: ItemUpdateType): void {\n    const currentFrameNumber = payload.frame!;\n    const items = this.frames[currentFrameNumber]?.items ?? [];\n    items.push(payload);\n\n    // Set items with newest\n    set(this.frames, [currentFrameNumber, \"items\"], items);\n  }\n\n  private _handleFrameBookend(payload: FrameBookendType): void {\n    const latestFinalizedFrame = payload.latestFinalizedFrame!;\n    const currentFrameNumber = payload.frame!;\n    set(this.frames, [currentFrameNumber, \"isTransferComplete\"], true);\n    // Fire off a normal frame event\n    this.emit(SlpParserEvent.FRAME, this.frames[currentFrameNumber]);\n\n    // Finalize frames if necessary\n    const validLatestFrame = this.settings!.gameMode === GameMode.ONLINE;\n    if (validLatestFrame && latestFinalizedFrame >= Frames.FIRST) {\n      // Ensure valid latestFinalizedFrame\n      if (this.options.strict && latestFinalizedFrame < currentFrameNumber - MAX_ROLLBACK_FRAMES) {\n        throw new Error(`latestFinalizedFrame should be within ${MAX_ROLLBACK_FRAMES} frames of ${currentFrameNumber}`);\n      }\n      this._finalizeFrames(latestFinalizedFrame);\n    } else {\n      // Since we don't have a valid finalized frame, just finalize the frame based on MAX_ROLLBACK_FRAMES\n      this._finalizeFrames(currentFrameNumber - MAX_ROLLBACK_FRAMES);\n    }\n  }\n\n  /**\n   * Fires off the FINALIZED_FRAME event for frames up until a certain number\n   * @param num The frame to finalize until\n   */\n  private _finalizeFrames(num: number): void {\n    while (this.lastFinalizedFrame < num) {\n      const frameToFinalize = this.lastFinalizedFrame + 1;\n      const frame = this.getFrame(frameToFinalize)!;\n\n      // Check that we have all the pre and post frame data for all players if we're in strict mode\n      if (this.options.strict) {\n        for (const player of this.settings!.players) {\n          const playerFrameInfo = frame.players[player.playerIndex];\n          // Allow player frame info to be empty in non 1v1 games since\n          // players which have been defeated will have no frame info.\n          if (this.settings!.players.length > 2 && !playerFrameInfo) {\n            continue;\n          }\n\n          const { pre, post } = playerFrameInfo!;\n          if (!pre || !post) {\n            const preOrPost = pre ? \"pre\" : \"post\";\n            throw new Error(\n              `Could not finalize frame ${frameToFinalize} of ${num}: missing ${preOrPost}-frame update for player ${player.playerIndex}`,\n            );\n          }\n        }\n      }\n\n      // Our frame is complete so finalize the frame\n      this.emit(SlpParserEvent.FINALIZED_FRAME, frame);\n      this.lastFinalizedFrame = frameToFinalize;\n    }\n  }\n\n  private _completeSettings(): void {\n    if (!this.settingsComplete) {\n      this.settingsComplete = true;\n      this.emit(SlpParserEvent.SETTINGS, this.settings);\n    }\n  }\n}\n"],"names":["MAX_ROLLBACK_FRAMES","SlpParserEvent","defaultSlpParserOptions","strict","SlpParser","EventEmitter","constructor","options","frames","rollbackCounter","RollbackCounter","settings","gameEnd","latestFrameIndex","settingsComplete","lastFinalizedFrame","Frames","FIRST","geckoList","Object","assign","handleCommand","command","payload","Command","GAME_START","_handleGameStart","FRAME_START","_handleFrameStart","POST_FRAME_UPDATE","_handlePostFrameUpdate","_handleFrameUpdate","PRE_FRAME_UPDATE","ITEM_UPDATE","_handleItemUpdate","FRAME_BOOKEND","_handleFrameBookend","GAME_END","_handleGameEnd","GECKO_LIST","_handleGeckoList","reset","getLatestFrameNumber","getPlayableFrameCount","FIRST_PLAYABLE","getLatestFrame","allFrames","getFrames","frameIndex","indexToUse","get","getSettings","getGameEnd","getRollbackFrames","count","getCount","lengths","getLengths","getFrame","num","getGeckoList","_finalizeFrames","emit","END","players","filter","player","type","slpVersion","semver","gte","_completeSettings","currentFrameNumber","frame","set","playerIndex","playersByIndex","keyBy","internalCharacterId","characterId","location","field","isFollower","currentFrame","wasRolledback","checkIfRollbackFrame","ROLLBACK_FRAME","lte","FRAME","items","push","latestFinalizedFrame","validLatestFrame","gameMode","GameMode","ONLINE","Error","frameToFinalize","playerFrameInfo","length","pre","post","preOrPost","FINALIZED_FRAME","SETTINGS"],"mappings":"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"}